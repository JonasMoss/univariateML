expect_error(mlnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlnorm(small_data),
mlnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlnorm(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)
)
est
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Laplace")
expect_equal(class(est), "univariateML")
covr::report()
?extraDistr::LocationScaleT
?DT
?dt
dwilcox
?LogNormal
?dlnorm
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
#' Estimates the parameter of the log-normal distribution using maximum likelihood
#'
#' The maximum likelihood estimate of \code{meanlog} is the empirical mean of the
#'     log-transformed data and the maximum likelihood estimate of \code{sdlog}
#'     is the square root of the biased sample variance based on the
#'     log-transformed data.
#'
#' @param x The data from which the estimate is to be computed.
#' @param na.rm logical. Should missing values be removed?
#' @return A named numeric vector with maximum likelihood estimates for
#' \code{meanlog} and \code{sdlog}.
#' @export
mllnorm = function(x, na.rm = FALSE) {
if(na.rm) x = x[!is.na(x)] else assertthat::assert_that(!anyNA(x))
assertthat::assert_that(min(x) >= 0)
y = log(x)
n = length(x)
object = c(meanlog = mean(y),
sdlog = sqrt(var(y)*(n-1)/n))
class(object) = "univariateML"
attr(object, "model") = "Lognormal"
attr(object, "logLik") = -n/2*(1 + log(2*pi) + 2*log(sigma) + mu)
object
}
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE))
devtools::load_all(".")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
covr::report()
?dgamma
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
est
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)
)
est
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
## Data generation.
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
## Checks if the ML is correct.
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
## Checks warning with small iterlim.
expect_warning(mlgamma(tiny_data, iterlim = 1))
## Finds errors with na and data out of bounds.
expect_error(mlgamma(c(tiny_data, NA)))
expect_error(mlgamma(c(tiny_data, 0)))
## Checks that na.rm works as intended.
expect_equal(mlgamma(small_data),
mlgamma(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
covr::report()
?Cauchy
stats::median
stats::nlm
mean
stats::sd
devtools::load_all(".")
class(1:10)
class(runif(10))
extraDistr::dtnorm()
?extraDistr::dtnorm
dexp
?dgamma
?dweibull
?dlogic
?dlogis
usethis::use_travis()
dgumbel
library("extraDistr")
dgumbel
dkumar
dbetapr
?dbetapr
dwald
dlaplace
drayleigh
dpareto
?dpower
dlomax
dinvgamma
mlwald
mlrayleigh
dpareto
?dpareto
?dpowe
?dpower
mllomaxc
mllomax
devtools::load_all(".")
rrayleigh
context("mlrayleigh")
## Data generation.
set.seed(313)
small_data = extraDistr::rayleigh(100, 2)
tiny_data= extraDistr::rrayleigh(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlrayleigh(c(-.1, tiny_data)))
expect_error(mlrayleigh(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlrayleigh(small_data),
mlrayleigh(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlrayleigh(small_data, na.rm = TRUE)
expect_equal(sum(dexp(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Rayleigh")
expect_equal(class(est), "univariateML")
context("mlrayleigh")
## Data generation.
set.seed(313)
small_data = extraDistr::rayleigh(100, 2)
tiny_data= extraDistr::rrayleigh(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlrayleigh(c(-.1, tiny_data)))
expect_error(mlrayleigh(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlrayleigh(small_data),
mlrayleigh(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlrayleigh(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::drayleigh(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Rayleigh")
expect_equal(class(est), "univariateML")
context("mlrayleigh")
## Data generation.
set.seed(313)
small_data = extraDistr::rrayleigh(100, 2)
tiny_data= extraDistr::rrayleigh(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlrayleigh(c(-.1, tiny_data)))
expect_error(mlrayleigh(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlrayleigh(small_data),
mlrayleigh(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlrayleigh(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::drayleigh(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Rayleigh")
expect_equal(class(est), "univariateML")
context("mlrayleigh")
## Data generation.
set.seed(313)
small_data = extraDistr::rrayleigh(100, 2)
tiny_data= extraDistr::rrayleigh(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlrayleigh(c(-.1, tiny_data)))
expect_error(mlrayleigh(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlrayleigh(small_data),
mlrayleigh(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlrayleigh(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::drayleigh(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Rayleigh")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlrayleigh")
## Data generation.
set.seed(313)
small_data = extraDistr::rrayleigh(100, 2)
tiny_data= extraDistr::rrayleigh(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlrayleigh(c(-.1, tiny_data)))
expect_error(mlrayleigh(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlrayleigh(small_data),
mlrayleigh(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlrayleigh(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::drayleigh(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Rayleigh")
expect_equal(class(est), "univariateML")
