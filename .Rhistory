#' @param x The data from which the estimate is to be computed.
#' @param na.rm logical. Should missing values be removed?
#' @return A named numeric vector with maximum likelihood estimates for
#' \code{rate}.
#' @export
mlexp = function(x, na.rm = FALSE) {
if(na.rm) x = x[!is.na(x)] else assertthat::assert_that(!anyNA(x))
assertthat::assert_that(min(x) >= 0)
rate = 1/mean(x)
object = c(rate = rate)
class(object) = "univariateML"
attr(object, "model") = "Exponential"
attr(object, "logLik") = length(x)*(log(rate) - 1)
object
}
context("mlbeta")
## Data generation.
set.seed(313)
small_data = rexp(100, 2)
tiny_data= rexp(10, 3)
## Finds errors with na and data out of bounds.
expect_error(mlexp(c(-.1, tiny_data)))
expect_error(mlexp(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlexp(small_data),
mlexp(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlexp(small_data, na.rm = TRUE)
expect_equal(sum(dexp(small_data, est, log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Exponential")
expect_equal(class(est), "univariateML")
sum(dexp(small_data, est, log = TRUE))
attr(est, "logLik")
devtools::load_all(".")
devtools::load_all(".")
covr::report()
?dnorm
devtools::load_all(".")
context("mlnorm")
## Data generation.
set.seed(313)
small_data = rnorm(100, 2, 3)
tiny_data= rnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mlnorm(c(-.1, tiny_data)))
expect_error(mlnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlnorm(small_data),
mlnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlnorm(small_data, na.rm = TRUE)
expect_equal(sum(dnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlnorm")
## Data generation.
set.seed(313)
small_data = rnorm(100, 2, 3)
tiny_data= rnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mlnorm(c(-.1, tiny_data)))
expect_error(mlnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlnorm(small_data),
mlnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlnorm(small_data, na.rm = TRUE)
expect_equal(sum(dnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
#' Estimates the parameter of the normal distribution using maximum likelihood
#'
#' The maximum likelihood estimate of \code{mean} is the empirical mean and the
#'     maximum likelihood estimate of \code{sd} is the square root of the
#'     biased sample variance.
#'
#' @param x The data from which the estimate is to be computed.
#' @param na.rm logical. Should missing values be removed?
#' @return A named numeric vector with maximum likelihood estimates for
#' \code{mean} and \code{sd}.
#' @export
mlnorm = function(x, na.rm = FALSE) {
if(na.rm) x = x[!is.na(x)] else assertthat::assert_that(!anyNA(x))
n = length(x)
mu = mean(x)
sigma = sqrt(var(x)*(n-1)/n)
object = c(mean = mu, sd = sigma)
class(object) = "univariateML"
attr(object, "model") = "Normal"
attr(object, "logLik") = -n/2*(1 + log(2*pi) + 2*log(sigma))
object
}
devtools::load_all(".")
devtools::load_all(".")
context("mlnorm")
## Data generation.
set.seed(313)
small_data = rnorm(100, 2, 3)
tiny_data= rnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mlnorm(c(-.1, tiny_data)))
expect_error(mlnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlnorm(small_data),
mlnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlnorm(small_data, na.rm = TRUE)
expect_equal(sum(dnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
covr::report()
dlaplace
devtools::load_all(".")
devtools::load_all(".")
context("mlnorm")
## Data generation.
set.seed(313)
small_data = extraDistr::dlaplace(100, 2, 3)
tiny_data= extraDistr::dlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mlnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mlnorm(small_data),
mlnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlnorm(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)
)
est
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Normal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllaplace")
## Data generation.
set.seed(313)
small_data = extraDistr::rlaplace(100, 2, 3)
tiny_data= extraDistr::rlaplace(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllaplace(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllaplace(small_data),
mllaplace(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllaplace(small_data, na.rm = TRUE)
expect_equal(sum(extraDistr::dlaplace(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Laplace")
expect_equal(class(est), "univariateML")
covr::report()
?extraDistr::LocationScaleT
?DT
?dt
dwilcox
?LogNormal
?dlnorm
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
#' Estimates the parameter of the log-normal distribution using maximum likelihood
#'
#' The maximum likelihood estimate of \code{meanlog} is the empirical mean of the
#'     log-transformed data and the maximum likelihood estimate of \code{sdlog}
#'     is the square root of the biased sample variance based on the
#'     log-transformed data.
#'
#' @param x The data from which the estimate is to be computed.
#' @param na.rm logical. Should missing values be removed?
#' @return A named numeric vector with maximum likelihood estimates for
#' \code{meanlog} and \code{sdlog}.
#' @export
mllnorm = function(x, na.rm = FALSE) {
if(na.rm) x = x[!is.na(x)] else assertthat::assert_that(!anyNA(x))
assertthat::assert_that(min(x) >= 0)
y = log(x)
n = length(x)
object = c(meanlog = mean(y),
sdlog = sqrt(var(y)*(n-1)/n))
class(object) = "univariateML"
attr(object, "model") = "Lognormal"
attr(object, "logLik") = -n/2*(1 + log(2*pi) + 2*log(sigma) + mu)
object
}
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE))
devtools::load_all(".")
devtools::load_all(".")
context("mllnorm")
## Data generation.
set.seed(313)
small_data = stats::rlnorm(100, 2, 3)
tiny_data= stats::rlnorm(10, 0, 1)
## Finds errors with na and data out of bounds.
expect_error(mllnorm(c(tiny_data, NA)))
## Checks that na.rm works as intended.
expect_equal(mllnorm(small_data),
mllnorm(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dlnorm(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
covr::report()
?dgamma
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Check class.
expect_equal(attr(est, "model"), "Lognormal")
expect_equal(class(est), "univariateML")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
est
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mllnorm(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)
)
est
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
expect_warning(mlgamma(tiny_data, iterlim = 1))
expect_error(mlgamma(c(tiny_data, 0)))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
devtools::load_all(".")
context("mlgamma")
## Data generation.
set.seed(313)
small_data = stats::rgamma(100, 1, 1)
tiny_data = stats::rgamma(10, 3, 7)
data3 = c(0, tiny_data)
## Checks if the ML is correct.
mle1 = nlm(function(p) {
-mean(stats::dgamma(small_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
mle2 = nlm(function(p) {
-mean(stats::dgamma(tiny_data, p[1], p[2], log = TRUE))
}, p = c(1,1))$estimate
expect_equal(mle1, as.numeric(mlgamma(small_data)), tolerance = 1e-5)
expect_equal(mle2, as.numeric(mlgamma(tiny_data)), tolerance = 1e-5)
## Checks warning with small iterlim.
expect_warning(mlgamma(tiny_data, iterlim = 1))
## Finds errors with na and data out of bounds.
expect_error(mlgamma(c(tiny_data, NA)))
expect_error(mlgamma(c(tiny_data, 0)))
## Checks that na.rm works as intended.
expect_equal(mlgamma(small_data),
mlgamma(c(small_data, NA), na.rm = TRUE))
## Is the log-likelihood correct?
est = mlgamma(small_data, na.rm = TRUE)
expect_equal(sum(stats::dgamma(small_data, est[1], est[2], log = TRUE)),
attr(est, "logLik"))
## Check class.
expect_equal(attr(est, "model"), "Gamma")
expect_equal(class(est), "univariateML")
covr::report()
